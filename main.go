package main

import (
	"bufio"
	"bytes"
	"context"
	"crypto/tls"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"net/smtp"
	"net/textproto"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/google/gops/agent"
	"github.com/pkg/errors"
	"golang.org/x/time/rate"
)

var (
	myDate     = time.Now()
	myPid      = os.Getpid()
	myhostname = "localhost"
)

var (
	defaultSender    = "from@example.com"
	defaultRecipient = "to@example.com"
	defaultSubject   = "from go-smtp-source"
)

var config *Config

type Config struct {
	Host   string
	Sender string

	Recipient      string
	RecipientCount int

	MessageCount int
	Sessions     int
	MessageSize  int
	Subject      string

	DontDisconnect bool
	Verbose        bool

	// extension
	UseTLS      bool
	ResolveOnce bool
	QPS         rate.Limit

	File string

	tlsConfig *tls.Config
}

func usage(m, def string) string {
	return fmt.Sprintf("%s [default: %s]", m, def)
}

func Parse() error {
	var (
		msgcount = flag.Int("m", 1, usage("specify a number of messages to send.", "1"))
		msgsize  = flag.Int("l", 0, usage("specify the size of the body.", "0"))
		session  = flag.Int("s", 1, usage("specify a number of concurrent sessions.", "1"))
		sender   = flag.String("f", defaultSender, usage("specify a sender address.", defaultSender))
		subject  = flag.String("S", defaultSubject, usage("specify a subject.", defaultSubject))

		dontDisconnect = flag.Bool("d", false, usage("do not disconnect after sending a message; send the next message over the same connection.", "false"))

		verbose = flag.Bool("v", false, usage("enable verbose mode.", "false"))

		recipient = flag.String("t", defaultRecipient, usage("specify a recipient address.", defaultRecipient))

		recipientCount = flag.Int(
			"r", 1,
			usage("specify the number of recipients to send per transaction. Recipient names are generated by prepending a number to the recipient address.", "1"),
		)

		usetls      = flag.Bool("tls", false, usage("specify if STARTTLS is needed.", "false"))
		resolveOnce = flag.Bool("resolve-once", false, usage("resolve the hostname only once.", "false"))

		qps = flag.Float64("q", 0, usage("specify a queries per second.", "no rate limit"))

		file = flag.String("F", "", "send a preformatted header and message specified in the file.")
	)

	flag.Parse()

	host := flag.Arg(0)
	if host == "" {
		return errors.New("host is missing")
	}

	config = &Config{
		Host:   host,
		Sender: *sender,

		Recipient:      *recipient,
		RecipientCount: *recipientCount,

		MessageCount: *msgcount,
		MessageSize:  *msgsize,
		Sessions:     *session,
		Subject:      *subject,

		DontDisconnect: *dontDisconnect,
		Verbose:        *verbose,

		UseTLS:      *usetls,
		ResolveOnce: *resolveOnce,

		QPS: rate.Limit(*qps),

		File: *file,

		tlsConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
	}
	return nil
}

type clientCall struct {
	c   *smtp.Client
	err error

	initialized bool
}

type transaction struct {
	Sender     string
	Recipients []string
	TxIdx      int
	Data       []byte
}

func sendMail(c *smtp.Client, initialized bool, tx *transaction) (bool, error) {
	if !initialized {
		if config.UseTLS {
			if err := c.StartTLS(config.tlsConfig); err != nil {
				return initialized, errors.Wrap(err, "unable to issue STARTTLS")
			}
		} else {
			if err := c.Hello(myhostname); err != nil {
				return initialized, errors.Wrap(err, "unable to say hello")
			}
		}

		initialized = true
	}

	if err := c.Mail(config.Sender); err != nil {
		return initialized, errors.Wrap(err, "unable to start SMTP transaction")
	}

	for i := range tx.Recipients {
		if err := c.Rcpt(tx.Recipients[i]); err != nil {
			return initialized, errors.Wrap(err, "unable to issue RCPT")
		}
	}

	wc, err := c.Data()
	if err != nil {
		return initialized, errors.Wrap(err, "unable to start DATA")
	}
	if data := tx.Data; len(data) > 0 {
		if _, err := wc.Write(data); err != nil {
			return initialized, errors.Wrap(err, "unable to write preformatted data")
		}
	} else {
		fmt.Fprintf(wc, "From: <%s>\n", config.Sender)
		fmt.Fprintf(wc, "To: <%s>\n", config.Recipient)
		fmt.Fprintf(wc, "Date: %s\n", myDate.Format(time.RFC1123))

		subject := fmt.Sprintf(config.Subject, tx.TxIdx)
		if subjectIdx := strings.Index(subject, "%!(EXTRA"); subjectIdx >= 0 {
			fmt.Fprintf(wc, "Subject: %s\n", subject[0:subjectIdx])
		} else {
			fmt.Fprintf(wc, "Subject: %s\n", subject)
		}
		fmt.Fprintf(wc, "Message-Id: <%04x.%04x@%s>\n", myPid, config.MessageCount, myhostname)
		fmt.Fprintln(wc, "")

		if config.MessageSize == 0 {
			for i := 1; i < 5; i++ {
				fmt.Fprintf(wc, "La de da de da %d.\n", i)
			}
		} else {
			for i := 1; i < config.MessageSize; i++ {
				fmt.Fprint(wc, "X")
				if i%80 == 0 {
					fmt.Fprint(wc, "\n")
				}
			}
		}
	}

	return initialized, errors.Wrap(wc.Close(), "unable to commit the SMTP transaction")
}

// txidx starts from 1.
func generateRecipients(rcpt string, txidx, recipientCount, nrcpt int) []string {
	pos := 1
	if txidx > 1 {
		pos += (txidx - 1) * recipientCount
	}

	recipients := make([]string, 0, nrcpt)
	for i := 0; i < nrcpt; i++ {
		recipients = append(recipients, fmt.Sprintf("%d_%s", pos, rcpt))
		pos++
	}

	return recipients
}

func formatData(fn string) ([]byte, error) {
	f, err := os.Open(fn)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to open '%s'", fn)
	}
	defer f.Close()

	buf := &bytes.Buffer{}
	w := textproto.NewWriter(bufio.NewWriter(buf)).DotWriter()
	if _, err := io.Copy(w, f); err != nil {
		return nil, err
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "failed to close")
	}

	return buf.Bytes(), nil
}

func main() {
	if err := agent.Listen(agent.Options{}); err != nil {
		log.Fatal(err)
	}
	if err := Parse(); err != nil {
		log.Fatal(err)
	}

	var data []byte
	if fn := config.File; fn != "" {
		data_, err := formatData(fn)
		if err != nil {
			log.Fatal(err)
		}
		data = data_
	}

	addr, port, err := net.SplitHostPort(config.Host)
	if err != nil {
		log.Fatal(err)
	}

	if config.ResolveOnce {
		addrs, err := net.LookupHost(addr)
		if err != nil {
			log.Fatal(err)
		}

		// use first one
		addr = addrs[0]
	}

	clientCh := make(chan *clientCall, config.Sessions)
	clientCtx, clientCancel := context.WithCancel(context.Background())

	clientSessionDone := make(chan struct{})

	if config.DontDisconnect {
		go func() {
			defer func() {
				close(clientSessionDone)

				if config.Verbose {
					log.Print("clientSession is done")
				}
			}()

			for i := 1; i <= config.Sessions; i++ {
				select {
				case <-clientCtx.Done():
					if config.Verbose {
						log.Print("client ctx is canceled. no longer create a new connection.")
					}

					return
				default:
				}

				if config.Verbose {
					log.Printf("Opening a SMTP session (%d)...", i)
				}

				// opening a connection first
				conn, err := net.Dial("tcp", addr+":"+port)
				if err != nil {
					log.Fatalf("opening a SMTP session: %s", err)
				}

				if tcpConn, ok := conn.(*net.TCPConn); ok {
					// smtp-source does this so we just follow it
					if err := tcpConn.SetLinger(0); err != nil {
						log.Fatalf("setting linger to SMTP session (%d)...", i)
					}
				}

				sc, err := smtp.NewClient(conn, addr)
				clientCh <- &clientCall{sc, nil, false}
			}
		}()
	}

	ntx := config.MessageCount
	txCh := make(chan *transaction, ntx)

	go func() {
		for i := 0; i < ntx; i++ {
			txidx := i + 1

			nrcpt := config.RecipientCount

			tx := &transaction{
				Sender: config.Sender,
				TxIdx:  txidx,
				Data:   data,
			}

			if config.RecipientCount > 1 {
				tx.Recipients = generateRecipients(config.Recipient, txidx, config.RecipientCount, nrcpt)
			} else {
				tx.Recipients = []string{config.Recipient}
			}

			if config.Verbose {
				log.Printf("ntx:%d i:%d txidx:%d nrcpt:%d recipients:%v", ntx, i, txidx, nrcpt, tx.Recipients)
			}

			if !config.DontDisconnect {
				if config.Verbose {
					log.Printf("Opening a SMTP session (%d)...", txidx)
				}

				conn, err := net.Dial("tcp", addr+":"+port)
				if err != nil {
					clientCh <- &clientCall{nil, err, false}
					continue
				}

				if tcpConn, ok := conn.(*net.TCPConn); ok {
					// smtp-source does this so we just follow it
					if err := tcpConn.SetLinger(0); err != nil {
						clientCh <- &clientCall{nil, err, false}
						continue
					}
				}

				c, err := smtp.NewClient(conn, addr)
				clientCh <- &clientCall{c, err, false}
			}

			txCh <- tx
		}
	}()

	// wait group for all attempts
	var wg sync.WaitGroup
	wg.Add(ntx)

	limiter := rate.NewLimiter(rate.Inf, 0)
	if config.QPS > 0 {
		limiter = rate.NewLimiter(config.QPS, config.RecipientCount)
	}

	for i := 0; i < ntx; i++ {
		cc := <-clientCh

		go func(cc *clientCall, txidx int) {
			defer func() {
				if config.DontDisconnect {
					clientCh <- cc
				}
				wg.Done()
			}()

			if cc.err != nil {
				log.Println("unable to connect to the server:", cc.err)
				return
			}

			tx := <-txCh

			limiter.WaitN(context.TODO(), len(tx.Recipients))
			initialized, err := sendMail(cc.c, cc.initialized, tx)
			if err != nil {
				log.Fatal("unable to send a mail:", err)
			}

			cc.initialized = initialized

			if !config.DontDisconnect {
				if err := cc.c.Quit(); err != nil {
					log.Println("unable to quit a session:", err)
				}

				if config.Verbose {
					log.Printf("The SMTP session (%d) has been closed.", txidx+1)
				}
			}
		}(cc, i)
	}

	if config.Verbose {
		log.Printf("Waiting for the messages to be sent....")
	}

	wg.Wait()
	clientCancel()

	if config.Verbose {
		log.Printf("Client opening session context has been canceled")
	}

	clientCloseDone := make(chan struct{})

	if config.DontDisconnect {
		go func() {
			defer func() {
				close(clientCloseDone)
			}()

			if config.Verbose {
				log.Print("Closing all the SMTP sessions...")
			}

			i := 1
			for cc := range clientCh {
				if err := cc.c.Quit(); err != nil {
					log.Fatal("unable to quit a session:", err)
				}

				if config.Verbose {
					log.Printf("The SMTP session (%d) has been closed.", i)
				}

				i++
			}
		}()

		if config.Verbose {
			log.Print("Waiting for the client session is done...")
		}

		<-clientSessionDone
		close(clientCh)

		if config.Verbose {
			log.Print("Waiting for all the sessions are closed...")
		}

		<-clientCloseDone

		if config.Verbose {
			log.Print("All the sessions has been closed.")
		}
	}
}
